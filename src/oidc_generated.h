// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OIDC_OIDC_H_
#define FLATBUFFERS_GENERATED_OIDC_OIDC_H_

#include "flatbuffers/flatbuffers.h"

namespace OIDC {

struct Token;
struct TokenT;

struct Error;
struct ErrorT;

struct TokenT : public flatbuffers::NativeTable {
  typedef Token TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "OIDC.TokenT";
  }
  std::string access_token;
  std::string token_type;
  std::string grant_type;
  std::string refresh_token;
  int32_t expires_in;
  std::string id_token;
  TokenT()
      : expires_in(0) {
  }
};

struct Token FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TokenT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "OIDC.Token";
  }
  enum {
    VT_ACCESS_TOKEN = 4,
    VT_TOKEN_TYPE = 6,
    VT_GRANT_TYPE = 8,
    VT_REFRESH_TOKEN = 10,
    VT_EXPIRES_IN = 12,
    VT_ID_TOKEN = 14
  };
  const flatbuffers::String *access_token() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCESS_TOKEN);
  }
  flatbuffers::String *mutable_access_token() {
    return GetPointer<flatbuffers::String *>(VT_ACCESS_TOKEN);
  }
  const flatbuffers::String *token_type() const {
    return GetPointer<const flatbuffers::String *>(VT_TOKEN_TYPE);
  }
  flatbuffers::String *mutable_token_type() {
    return GetPointer<flatbuffers::String *>(VT_TOKEN_TYPE);
  }
  const flatbuffers::String *grant_type() const {
    return GetPointer<const flatbuffers::String *>(VT_GRANT_TYPE);
  }
  flatbuffers::String *mutable_grant_type() {
    return GetPointer<flatbuffers::String *>(VT_GRANT_TYPE);
  }
  const flatbuffers::String *refresh_token() const {
    return GetPointer<const flatbuffers::String *>(VT_REFRESH_TOKEN);
  }
  flatbuffers::String *mutable_refresh_token() {
    return GetPointer<flatbuffers::String *>(VT_REFRESH_TOKEN);
  }
  int32_t expires_in() const {
    return GetField<int32_t>(VT_EXPIRES_IN, 0);
  }
  bool mutate_expires_in(int32_t _expires_in) {
    return SetField<int32_t>(VT_EXPIRES_IN, _expires_in, 0);
  }
  const flatbuffers::String *id_token() const {
    return GetPointer<const flatbuffers::String *>(VT_ID_TOKEN);
  }
  flatbuffers::String *mutable_id_token() {
    return GetPointer<flatbuffers::String *>(VT_ID_TOKEN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACCESS_TOKEN) &&
           verifier.Verify(access_token()) &&
           VerifyOffset(verifier, VT_TOKEN_TYPE) &&
           verifier.Verify(token_type()) &&
           VerifyOffset(verifier, VT_GRANT_TYPE) &&
           verifier.Verify(grant_type()) &&
           VerifyOffset(verifier, VT_REFRESH_TOKEN) &&
           verifier.Verify(refresh_token()) &&
           VerifyField<int32_t>(verifier, VT_EXPIRES_IN) &&
           VerifyOffset(verifier, VT_ID_TOKEN) &&
           verifier.Verify(id_token()) &&
           verifier.EndTable();
  }
  TokenT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TokenT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Token> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TokenT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TokenBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_access_token(flatbuffers::Offset<flatbuffers::String> access_token) {
    fbb_.AddOffset(Token::VT_ACCESS_TOKEN, access_token);
  }
  void add_token_type(flatbuffers::Offset<flatbuffers::String> token_type) {
    fbb_.AddOffset(Token::VT_TOKEN_TYPE, token_type);
  }
  void add_grant_type(flatbuffers::Offset<flatbuffers::String> grant_type) {
    fbb_.AddOffset(Token::VT_GRANT_TYPE, grant_type);
  }
  void add_refresh_token(flatbuffers::Offset<flatbuffers::String> refresh_token) {
    fbb_.AddOffset(Token::VT_REFRESH_TOKEN, refresh_token);
  }
  void add_expires_in(int32_t expires_in) {
    fbb_.AddElement<int32_t>(Token::VT_EXPIRES_IN, expires_in, 0);
  }
  void add_id_token(flatbuffers::Offset<flatbuffers::String> id_token) {
    fbb_.AddOffset(Token::VT_ID_TOKEN, id_token);
  }
  explicit TokenBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TokenBuilder &operator=(const TokenBuilder &);
  flatbuffers::Offset<Token> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Token>(end);
    return o;
  }
};

inline flatbuffers::Offset<Token> CreateToken(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> access_token = 0,
    flatbuffers::Offset<flatbuffers::String> token_type = 0,
    flatbuffers::Offset<flatbuffers::String> grant_type = 0,
    flatbuffers::Offset<flatbuffers::String> refresh_token = 0,
    int32_t expires_in = 0,
    flatbuffers::Offset<flatbuffers::String> id_token = 0) {
  TokenBuilder builder_(_fbb);
  builder_.add_id_token(id_token);
  builder_.add_expires_in(expires_in);
  builder_.add_refresh_token(refresh_token);
  builder_.add_grant_type(grant_type);
  builder_.add_token_type(token_type);
  builder_.add_access_token(access_token);
  return builder_.Finish();
}

inline flatbuffers::Offset<Token> CreateTokenDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *access_token = nullptr,
    const char *token_type = nullptr,
    const char *grant_type = nullptr,
    const char *refresh_token = nullptr,
    int32_t expires_in = 0,
    const char *id_token = nullptr) {
  return OIDC::CreateToken(
      _fbb,
      access_token ? _fbb.CreateString(access_token) : 0,
      token_type ? _fbb.CreateString(token_type) : 0,
      grant_type ? _fbb.CreateString(grant_type) : 0,
      refresh_token ? _fbb.CreateString(refresh_token) : 0,
      expires_in,
      id_token ? _fbb.CreateString(id_token) : 0);
}

flatbuffers::Offset<Token> CreateToken(flatbuffers::FlatBufferBuilder &_fbb, const TokenT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ErrorT : public flatbuffers::NativeTable {
  typedef Error TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "OIDC.ErrorT";
  }
  int32_t code;
  std::string message;
  std::string status;
  ErrorT()
      : code(0) {
  }
};

struct Error FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ErrorT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "OIDC.Error";
  }
  enum {
    VT_CODE = 4,
    VT_MESSAGE = 6,
    VT_STATUS = 8
  };
  int32_t code() const {
    return GetField<int32_t>(VT_CODE, 0);
  }
  bool mutate_code(int32_t _code) {
    return SetField<int32_t>(VT_CODE, _code, 0);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  const flatbuffers::String *status() const {
    return GetPointer<const flatbuffers::String *>(VT_STATUS);
  }
  flatbuffers::String *mutable_status() {
    return GetPointer<flatbuffers::String *>(VT_STATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CODE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.Verify(status()) &&
           verifier.EndTable();
  }
  ErrorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ErrorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Error> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ErrorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(int32_t code) {
    fbb_.AddElement<int32_t>(Error::VT_CODE, code, 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Error::VT_MESSAGE, message);
  }
  void add_status(flatbuffers::Offset<flatbuffers::String> status) {
    fbb_.AddOffset(Error::VT_STATUS, status);
  }
  explicit ErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ErrorBuilder &operator=(const ErrorBuilder &);
  flatbuffers::Offset<Error> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Error>(end);
    return o;
  }
};

inline flatbuffers::Offset<Error> CreateError(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t code = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    flatbuffers::Offset<flatbuffers::String> status = 0) {
  ErrorBuilder builder_(_fbb);
  builder_.add_status(status);
  builder_.add_message(message);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<Error> CreateErrorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t code = 0,
    const char *message = nullptr,
    const char *status = nullptr) {
  return OIDC::CreateError(
      _fbb,
      code,
      message ? _fbb.CreateString(message) : 0,
      status ? _fbb.CreateString(status) : 0);
}

flatbuffers::Offset<Error> CreateError(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TokenT *Token::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TokenT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Token::UnPackTo(TokenT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = access_token(); if (_e) _o->access_token = _e->str(); };
  { auto _e = token_type(); if (_e) _o->token_type = _e->str(); };
  { auto _e = grant_type(); if (_e) _o->grant_type = _e->str(); };
  { auto _e = refresh_token(); if (_e) _o->refresh_token = _e->str(); };
  { auto _e = expires_in(); _o->expires_in = _e; };
  { auto _e = id_token(); if (_e) _o->id_token = _e->str(); };
}

inline flatbuffers::Offset<Token> Token::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TokenT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateToken(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Token> CreateToken(flatbuffers::FlatBufferBuilder &_fbb, const TokenT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TokenT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _access_token = _o->access_token.empty() ? 0 : _fbb.CreateString(_o->access_token);
  auto _token_type = _o->token_type.empty() ? 0 : _fbb.CreateString(_o->token_type);
  auto _grant_type = _o->grant_type.empty() ? 0 : _fbb.CreateString(_o->grant_type);
  auto _refresh_token = _o->refresh_token.empty() ? 0 : _fbb.CreateString(_o->refresh_token);
  auto _expires_in = _o->expires_in;
  auto _id_token = _o->id_token.empty() ? 0 : _fbb.CreateString(_o->id_token);
  return OIDC::CreateToken(
      _fbb,
      _access_token,
      _token_type,
      _grant_type,
      _refresh_token,
      _expires_in,
      _id_token);
}

inline ErrorT *Error::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ErrorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Error::UnPackTo(ErrorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); _o->code = _e; };
  { auto _e = message(); if (_e) _o->message = _e->str(); };
  { auto _e = status(); if (_e) _o->status = _e->str(); };
}

inline flatbuffers::Offset<Error> Error::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateError(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Error> CreateError(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ErrorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code;
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  auto _status = _o->status.empty() ? 0 : _fbb.CreateString(_o->status);
  return OIDC::CreateError(
      _fbb,
      _code,
      _message,
      _status);
}

inline flatbuffers::TypeTable *TokenTypeTable();

inline flatbuffers::TypeTable *ErrorTypeTable();

inline flatbuffers::TypeTable *TokenTypeTable() {
  static flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char *names[] = {
    "access_token",
    "token_type",
    "grant_type",
    "refresh_token",
    "expires_in",
    "id_token"
  };
  static flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline flatbuffers::TypeTable *ErrorTypeTable() {
  static flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char *names[] = {
    "code",
    "message",
    "status"
  };
  static flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const OIDC::Token *GetToken(const void *buf) {
  return flatbuffers::GetRoot<OIDC::Token>(buf);
}

inline Token *GetMutableToken(void *buf) {
  return flatbuffers::GetMutableRoot<Token>(buf);
}

inline bool VerifyTokenBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<OIDC::Token>(nullptr);
}

inline void FinishTokenBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<OIDC::Token> root) {
  fbb.Finish(root);
}

inline std::unique_ptr<TokenT> UnPackToken(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<TokenT>(GetToken(buf)->UnPack(res));
}

}  // namespace OIDC

#endif  // FLATBUFFERS_GENERATED_OIDC_OIDC_H_
